{"version":3,"sources":["../../../../../../nodes/vector_store/shared/createVectorStoreNode/operations/loadOperation.ts"],"sourcesContent":["import type { Embeddings } from '@langchain/core/embeddings';\nimport type { VectorStore } from '@langchain/core/vectorstores';\nimport type { IExecuteFunctions, INodeExecutionData } from 'n8n-workflow';\n\nimport { getMetadataFiltersValues, logAiEvent } from '@utils/helpers';\n\nimport type { VectorStoreNodeConstructorArgs } from '../types';\n\n/**\n * Handles the 'load' operation mode\n * Searches the vector store for documents similar to a query\n */\nexport async function handleLoadOperation<T extends VectorStore = VectorStore>(\n\tcontext: IExecuteFunctions,\n\targs: VectorStoreNodeConstructorArgs<T>,\n\tembeddings: Embeddings,\n\titemIndex: number,\n): Promise<INodeExecutionData[]> {\n\tconst filter = getMetadataFiltersValues(context, itemIndex);\n\tconst vectorStore = await args.getVectorStoreClient(\n\t\tcontext,\n\t\t// We'll pass filter to similaritySearchVectorWithScore instead of getVectorStoreClient\n\t\tundefined,\n\t\tembeddings,\n\t\titemIndex,\n\t);\n\n\ttry {\n\t\t// Get the search parameters from the node\n\t\tconst prompt = context.getNodeParameter('prompt', itemIndex) as string;\n\t\tconst topK = context.getNodeParameter('topK', itemIndex, 4) as number;\n\t\tconst includeDocumentMetadata = context.getNodeParameter(\n\t\t\t'includeDocumentMetadata',\n\t\t\titemIndex,\n\t\t\ttrue,\n\t\t) as boolean;\n\n\t\t// Embed the prompt to prepare for vector similarity search\n\t\tconst embeddedPrompt = await embeddings.embedQuery(prompt);\n\n\t\t// Get the most similar documents to the embedded prompt\n\t\tconst docs = await vectorStore.similaritySearchVectorWithScore(embeddedPrompt, topK, filter);\n\n\t\t// Format the documents for the output\n\t\tconst serializedDocs = docs.map(([doc, score]) => {\n\t\t\tconst document = {\n\t\t\t\tpageContent: doc.pageContent,\n\t\t\t\t...(includeDocumentMetadata ? { metadata: doc.metadata } : {}),\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\tjson: { document, score },\n\t\t\t\tpairedItem: {\n\t\t\t\t\titem: itemIndex,\n\t\t\t\t},\n\t\t\t};\n\t\t});\n\n\t\t// Log the AI event for analytics\n\t\tlogAiEvent(context, 'ai-vector-store-searched', { query: prompt });\n\n\t\treturn serializedDocs;\n\t} finally {\n\t\t// Release the vector store client if a release method was provided\n\t\targs.releaseVectorStoreClient?.(vectorStore);\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,qBAAqD;AAQrD,eAAsB,oBACrB,SACA,MACA,YACA,WACgC;AAChC,QAAM,aAAS,yCAAyB,SAAS,SAAS;AAC1D,QAAM,cAAc,MAAM,KAAK;AAAA,IAC9B;AAAA;AAAA,IAEA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAEA,MAAI;AAEH,UAAM,SAAS,QAAQ,iBAAiB,UAAU,SAAS;AAC3D,UAAM,OAAO,QAAQ,iBAAiB,QAAQ,WAAW,CAAC;AAC1D,UAAM,0BAA0B,QAAQ;AAAA,MACvC;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAGA,UAAM,iBAAiB,MAAM,WAAW,WAAW,MAAM;AAGzD,UAAM,OAAO,MAAM,YAAY,gCAAgC,gBAAgB,MAAM,MAAM;AAG3F,UAAM,iBAAiB,KAAK,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;AACjD,YAAM,WAAW;AAAA,QAChB,aAAa,IAAI;AAAA,QACjB,GAAI,0BAA0B,EAAE,UAAU,IAAI,SAAS,IAAI,CAAC;AAAA,MAC7D;AAEA,aAAO;AAAA,QACN,MAAM,EAAE,UAAU,MAAM;AAAA,QACxB,YAAY;AAAA,UACX,MAAM;AAAA,QACP;AAAA,MACD;AAAA,IACD,CAAC;AAGD,mCAAW,SAAS,4BAA4B,EAAE,OAAO,OAAO,CAAC;AAEjE,WAAO;AAAA,EACR,UAAE;AAED,SAAK,2BAA2B,WAAW;AAAA,EAC5C;AACD;","names":[]}