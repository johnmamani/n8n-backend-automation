"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var InformationExtractor_node_exports = {};
__export(InformationExtractor_node_exports, {
  InformationExtractor: () => InformationExtractor
});
module.exports = __toCommonJS(InformationExtractor_node_exports);
var import_messages = require("@langchain/core/messages");
var import_prompts = require("@langchain/core/prompts");
var import_output_parsers = require("langchain/output_parsers");
var import_n8n_workflow = require("n8n-workflow");
var import_descriptions = require("../../../utils/descriptions");
var import_schemaParsing = require("../../../utils/schemaParsing");
var import_tracing = require("../../../utils/tracing");
var import_helpers = require("./helpers");
const SYSTEM_PROMPT_TEMPLATE = `You are an expert extraction algorithm.
Only extract relevant information from the text.
If you do not know the value of an attribute asked to extract, you may omit the attribute's value.`;
class InformationExtractor {
  constructor() {
    this.description = {
      displayName: "Information Extractor",
      name: "informationExtractor",
      icon: "fa:project-diagram",
      iconColor: "black",
      group: ["transform"],
      version: 1,
      description: "Extract information from text in a structured format",
      codex: {
        alias: ["NER", "parse", "parsing", "JSON", "data extraction", "structured"],
        categories: ["AI"],
        subcategories: {
          AI: ["Chains", "Root Nodes"]
        },
        resources: {
          primaryDocumentation: [
            {
              url: "https://docs.n8n.io/integrations/builtin/cluster-nodes/root-nodes/n8n-nodes-langchain.information-extractor/"
            }
          ]
        }
      },
      defaults: {
        name: "Information Extractor"
      },
      inputs: [
        { displayName: "", type: import_n8n_workflow.NodeConnectionTypes.Main },
        {
          displayName: "Model",
          maxConnections: 1,
          type: import_n8n_workflow.NodeConnectionTypes.AiLanguageModel,
          required: true
        }
      ],
      outputs: [import_n8n_workflow.NodeConnectionTypes.Main],
      properties: [
        {
          displayName: "Text",
          name: "text",
          type: "string",
          default: "",
          description: "The text to extract information from",
          typeOptions: {
            rows: 2
          }
        },
        {
          ...import_descriptions.schemaTypeField,
          description: "How to specify the schema for the desired output",
          options: [
            {
              name: "From Attribute Descriptions",
              value: "fromAttributes",
              description: "Extract specific attributes from the text based on types and descriptions"
            },
            ...import_descriptions.schemaTypeField.options
          ],
          default: "fromAttributes"
        },
        {
          ...import_descriptions.jsonSchemaExampleField,
          default: `{
	"state": "California",
	"cities": ["Los Angeles", "San Francisco", "San Diego"]
}`
        },
        {
          ...import_descriptions.inputSchemaField,
          default: `{
	"type": "object",
	"properties": {
		"state": {
			"type": "string"
		},
		"cities": {
			"type": "array",
			"items": {
				"type": "string"
			}
		}
	}
}`
        },
        {
          displayName: 'The schema has to be defined in the <a target="_blank" href="https://json-schema.org/">JSON Schema</a> format. Look at <a target="_blank" href="https://json-schema.org/learn/miscellaneous-examples.html">this</a> page for examples.',
          name: "notice",
          type: "notice",
          default: "",
          displayOptions: {
            show: {
              schemaType: ["manual"]
            }
          }
        },
        {
          displayName: "Attributes",
          name: "attributes",
          placeholder: "Add Attribute",
          type: "fixedCollection",
          default: {},
          displayOptions: {
            show: {
              schemaType: ["fromAttributes"]
            }
          },
          typeOptions: {
            multipleValues: true
          },
          options: [
            {
              name: "attributes",
              displayName: "Attribute List",
              values: [
                {
                  displayName: "Name",
                  name: "name",
                  type: "string",
                  default: "",
                  description: "Attribute to extract",
                  placeholder: "e.g. company_name",
                  required: true
                },
                {
                  displayName: "Type",
                  name: "type",
                  type: "options",
                  description: "Data type of the attribute",
                  required: true,
                  options: [
                    {
                      name: "Boolean",
                      value: "boolean"
                    },
                    {
                      name: "Date",
                      value: "date"
                    },
                    {
                      name: "Number",
                      value: "number"
                    },
                    {
                      name: "String",
                      value: "string"
                    }
                  ],
                  default: "string"
                },
                {
                  displayName: "Description",
                  name: "description",
                  type: "string",
                  default: "",
                  description: "Describe your attribute",
                  placeholder: "Add description for the attribute",
                  required: true
                },
                {
                  displayName: "Required",
                  name: "required",
                  type: "boolean",
                  default: false,
                  description: "Whether attribute is required",
                  required: true
                }
              ]
            }
          ]
        },
        {
          displayName: "Options",
          name: "options",
          type: "collection",
          default: {},
          placeholder: "Add Option",
          options: [
            {
              displayName: "System Prompt Template",
              name: "systemPromptTemplate",
              type: "string",
              default: SYSTEM_PROMPT_TEMPLATE,
              description: "String to use directly as the system prompt template",
              typeOptions: {
                rows: 6
              }
            }
          ]
        }
      ]
    };
  }
  async execute() {
    const items = this.getInputData();
    const llm = await this.getInputConnectionData(
      import_n8n_workflow.NodeConnectionTypes.AiLanguageModel,
      0
    );
    const schemaType = this.getNodeParameter("schemaType", 0, "");
    let parser;
    if (schemaType === "fromAttributes") {
      const attributes = this.getNodeParameter(
        "attributes.attributes",
        0,
        []
      );
      if (attributes.length === 0) {
        throw new import_n8n_workflow.NodeOperationError(this.getNode(), "At least one attribute must be specified");
      }
      parser = import_output_parsers.OutputFixingParser.fromLLM(
        llm,
        import_output_parsers.StructuredOutputParser.fromZodSchema((0, import_helpers.makeZodSchemaFromAttributes)(attributes))
      );
    } else {
      let jsonSchema;
      if (schemaType === "fromJson") {
        const jsonExample = this.getNodeParameter("jsonSchemaExample", 0, "");
        jsonSchema = (0, import_schemaParsing.generateSchema)(jsonExample);
      } else {
        const inputSchema = this.getNodeParameter("inputSchema", 0, "");
        jsonSchema = (0, import_n8n_workflow.jsonParse)(inputSchema);
      }
      const zodSchema = (0, import_schemaParsing.convertJsonSchemaToZod)(jsonSchema);
      parser = import_output_parsers.OutputFixingParser.fromLLM(llm, import_output_parsers.StructuredOutputParser.fromZodSchema(zodSchema));
    }
    const resultData = [];
    for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
      const input = this.getNodeParameter("text", itemIndex);
      const inputPrompt = new import_messages.HumanMessage(input);
      const options = this.getNodeParameter("options", itemIndex, {});
      const systemPromptTemplate = import_prompts.SystemMessagePromptTemplate.fromTemplate(
        `${options.systemPromptTemplate ?? SYSTEM_PROMPT_TEMPLATE}
{format_instructions}`
      );
      const messages = [
        await systemPromptTemplate.format({
          format_instructions: parser.getFormatInstructions()
        }),
        inputPrompt
      ];
      const prompt = import_prompts.ChatPromptTemplate.fromMessages(messages);
      const chain = prompt.pipe(llm).pipe(parser).withConfig((0, import_tracing.getTracingConfig)(this));
      try {
        const output = await chain.invoke(messages);
        resultData.push({ json: { output } });
      } catch (error) {
        if (this.continueOnFail()) {
          resultData.push({ json: { error: error.message }, pairedItem: { item: itemIndex } });
          continue;
        }
        throw error;
      }
    }
    return [resultData];
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  InformationExtractor
});
//# sourceMappingURL=InformationExtractor.node.js.map