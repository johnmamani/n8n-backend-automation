{"version":3,"sources":["../../../../nodes/mcp/McpTrigger/McpServer.ts"],"sourcesContent":["import type { Tool } from '@langchain/core/tools';\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport type { RequestHandlerExtra } from '@modelcontextprotocol/sdk/shared/protocol.js';\nimport type { JSONRPCMessage } from '@modelcontextprotocol/sdk/types.js';\nimport {\n\tJSONRPCMessageSchema,\n\tListToolsRequestSchema,\n\tCallToolRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport type * as express from 'express';\nimport { OperationalError, type Logger } from 'n8n-workflow';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\n\nimport { FlushingSSEServerTransport } from './FlushingSSEServerTransport';\nimport type { CompressionResponse } from './FlushingSSEServerTransport';\n\n/**\n * Parses the JSONRPC message and checks whether the method used was a tool\n * call. This is necessary in order to not have executions for listing tools\n * and other commands sent by the MCP client\n */\nfunction wasToolCall(body: string) {\n\ttry {\n\t\tconst message: unknown = JSON.parse(body);\n\t\tconst parsedMessage: JSONRPCMessage = JSONRPCMessageSchema.parse(message);\n\t\treturn (\n\t\t\t'method' in parsedMessage &&\n\t\t\t'id' in parsedMessage &&\n\t\t\tparsedMessage?.method === CallToolRequestSchema.shape.method.value\n\t\t);\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport class McpServer {\n\tservers: { [sessionId: string]: Server } = {};\n\n\ttransports: { [sessionId: string]: FlushingSSEServerTransport } = {};\n\n\tlogger: Logger;\n\n\tprivate tools: { [sessionId: string]: Tool[] } = {};\n\n\tprivate resolveFunctions: { [sessionId: string]: CallableFunction } = {};\n\n\tconstructor(logger: Logger) {\n\t\tthis.logger = logger;\n\t\tthis.logger.debug('MCP Server created');\n\t}\n\n\tasync connectTransport(postUrl: string, resp: CompressionResponse): Promise<void> {\n\t\tconst transport = new FlushingSSEServerTransport(postUrl, resp);\n\t\tconst server = this.setUpServer();\n\t\tconst { sessionId } = transport;\n\t\tthis.transports[sessionId] = transport;\n\t\tthis.servers[sessionId] = server;\n\n\t\tresp.on('close', async () => {\n\t\t\tthis.logger.debug(`Deleting transport for ${sessionId}`);\n\t\t\tdelete this.tools[sessionId];\n\t\t\tdelete this.resolveFunctions[sessionId];\n\t\t\tdelete this.transports[sessionId];\n\t\t\tdelete this.servers[sessionId];\n\t\t});\n\n\t\tawait server.connect(transport);\n\n\t\t// Make sure we flush the compression middleware, so that it's not waiting for more content to be added to the buffer\n\t\tif (resp.flush) {\n\t\t\tresp.flush();\n\t\t}\n\t}\n\n\tasync handlePostMessage(req: express.Request, resp: CompressionResponse, connectedTools: Tool[]) {\n\t\tconst sessionId = req.query.sessionId as string;\n\t\tconst transport = this.transports[sessionId];\n\t\tthis.tools[sessionId] = connectedTools;\n\t\tif (transport) {\n\t\t\t// We need to add a promise here because the `handlePostMessage` will send something to the\n\t\t\t// MCP Server, that will run in a different context. This means that the return will happen\n\t\t\t// almost immediately, and will lead to marking the sub-node as \"running\" in the final execution\n\t\t\tawait new Promise(async (resolve) => {\n\t\t\t\tthis.resolveFunctions[sessionId] = resolve;\n\t\t\t\tawait transport.handlePostMessage(req, resp, req.rawBody.toString());\n\t\t\t});\n\t\t\tdelete this.resolveFunctions[sessionId];\n\t\t} else {\n\t\t\tthis.logger.warn(`No transport found for session ${sessionId}`);\n\t\t\tresp.status(401).send('No transport found for sessionId');\n\t\t}\n\n\t\tif (resp.flush) {\n\t\t\tresp.flush();\n\t\t}\n\n\t\tdelete this.tools[sessionId]; // Clean up to avoid keeping all tools in memory\n\n\t\treturn wasToolCall(req.rawBody.toString());\n\t}\n\n\tsetUpServer(): Server {\n\t\tconst server = new Server(\n\t\t\t{\n\t\t\t\tname: 'n8n-mcp-server',\n\t\t\t\tversion: '0.1.0',\n\t\t\t},\n\t\t\t{\n\t\t\t\tcapabilities: { tools: {} },\n\t\t\t},\n\t\t);\n\n\t\tserver.setRequestHandler(ListToolsRequestSchema, async (_, extra: RequestHandlerExtra) => {\n\t\t\tif (!extra.sessionId) {\n\t\t\t\tthrow new OperationalError('Require a sessionId for the listing of tools');\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttools: this.tools[extra.sessionId].map((tool) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: tool.name,\n\t\t\t\t\t\tdescription: tool.description,\n\t\t\t\t\t\t// Allow additional properties on tool call input\n\t\t\t\t\t\tinputSchema: zodToJsonSchema(tool.schema, { removeAdditionalStrategy: 'strict' }),\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t};\n\t\t});\n\n\t\tserver.setRequestHandler(CallToolRequestSchema, async (request, extra: RequestHandlerExtra) => {\n\t\t\tif (!request.params?.name || !request.params?.arguments) {\n\t\t\t\tthrow new OperationalError('Require a name and arguments for the tool call');\n\t\t\t}\n\t\t\tif (!extra.sessionId) {\n\t\t\t\tthrow new OperationalError('Require a sessionId for the tool call');\n\t\t\t}\n\n\t\t\tconst requestedTool: Tool | undefined = this.tools[extra.sessionId].find(\n\t\t\t\t(tool) => tool.name === request.params.name,\n\t\t\t);\n\t\t\tif (!requestedTool) {\n\t\t\t\tthrow new OperationalError('Tool not found');\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst result = await requestedTool.invoke(request.params.arguments);\n\n\t\t\t\tthis.resolveFunctions[extra.sessionId]();\n\n\t\t\t\tthis.logger.debug(`Got request for ${requestedTool.name}, and executed it.`);\n\n\t\t\t\tif (typeof result === 'object') {\n\t\t\t\t\treturn { content: [{ type: 'text', text: JSON.stringify(result) }] };\n\t\t\t\t}\n\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\treturn { content: [{ type: 'text', text: result }] };\n\t\t\t\t}\n\t\t\t\treturn { content: [{ type: 'text', text: String(result) }] };\n\t\t\t} catch (error) {\n\t\t\t\tthis.logger.error(`Error while executing Tool ${requestedTool.name}: ${error}`);\n\t\t\t\treturn { isError: true, content: [{ type: 'text', text: `Error: ${error.message}` }] };\n\t\t\t}\n\t\t});\n\n\t\tserver.onclose = () => {\n\t\t\tthis.logger.debug('Closing MCP Server');\n\t\t};\n\t\tserver.onerror = (error: unknown) => {\n\t\t\tthis.logger.error(`MCP Error: ${error}`);\n\t\t};\n\t\treturn server;\n\t}\n}\n\n/**\n * This singleton is shared across the instance, making sure we only have one server to worry about.\n * It needs to stay in memory to keep track of the long-lived connections.\n * It requires a logger at first creation to set everything up.\n */\nexport class McpServerSingleton {\n\tstatic #instance: McpServerSingleton;\n\n\tprivate _serverData: McpServer;\n\n\tprivate constructor(logger: Logger) {\n\t\tthis._serverData = new McpServer(logger);\n\t}\n\n\tstatic instance(logger: Logger): McpServer {\n\t\tif (!McpServerSingleton.#instance) {\n\t\t\tMcpServerSingleton.#instance = new McpServerSingleton(logger);\n\t\t\tlogger.debug('Created singleton for MCP Servers');\n\t\t}\n\n\t\treturn McpServerSingleton.#instance.serverData;\n\t}\n\n\tget serverData() {\n\t\treturn this._serverData;\n\t}\n}\n"],"mappings":"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","names":[]}