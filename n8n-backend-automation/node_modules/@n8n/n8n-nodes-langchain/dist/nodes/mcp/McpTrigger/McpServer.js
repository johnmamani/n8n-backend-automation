"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var McpServer_exports = {};
__export(McpServer_exports, {
  McpServer: () => McpServer,
  McpServerSingleton: () => McpServerSingleton
});
module.exports = __toCommonJS(McpServer_exports);
var import_server = require("@modelcontextprotocol/sdk/server/index.js");
var import_types = require("@modelcontextprotocol/sdk/types.js");
var import_n8n_workflow = require("n8n-workflow");
var import_zod_to_json_schema = require("zod-to-json-schema");
var import_FlushingSSEServerTransport = require("./FlushingSSEServerTransport");
var _instance;
function wasToolCall(body) {
  try {
    const message = JSON.parse(body);
    const parsedMessage = import_types.JSONRPCMessageSchema.parse(message);
    return "method" in parsedMessage && "id" in parsedMessage && parsedMessage?.method === import_types.CallToolRequestSchema.shape.method.value;
  } catch {
    return false;
  }
}
class McpServer {
  constructor(logger) {
    this.servers = {};
    this.transports = {};
    this.tools = {};
    this.resolveFunctions = {};
    this.logger = logger;
    this.logger.debug("MCP Server created");
  }
  async connectTransport(postUrl, resp) {
    const transport = new import_FlushingSSEServerTransport.FlushingSSEServerTransport(postUrl, resp);
    const server = this.setUpServer();
    const { sessionId } = transport;
    this.transports[sessionId] = transport;
    this.servers[sessionId] = server;
    resp.on("close", async () => {
      this.logger.debug(`Deleting transport for ${sessionId}`);
      delete this.tools[sessionId];
      delete this.resolveFunctions[sessionId];
      delete this.transports[sessionId];
      delete this.servers[sessionId];
    });
    await server.connect(transport);
    if (resp.flush) {
      resp.flush();
    }
  }
  async handlePostMessage(req, resp, connectedTools) {
    const sessionId = req.query.sessionId;
    const transport = this.transports[sessionId];
    this.tools[sessionId] = connectedTools;
    if (transport) {
      await new Promise(async (resolve) => {
        this.resolveFunctions[sessionId] = resolve;
        await transport.handlePostMessage(req, resp, req.rawBody.toString());
      });
      delete this.resolveFunctions[sessionId];
    } else {
      this.logger.warn(`No transport found for session ${sessionId}`);
      resp.status(401).send("No transport found for sessionId");
    }
    if (resp.flush) {
      resp.flush();
    }
    delete this.tools[sessionId];
    return wasToolCall(req.rawBody.toString());
  }
  setUpServer() {
    const server = new import_server.Server(
      {
        name: "n8n-mcp-server",
        version: "0.1.0"
      },
      {
        capabilities: { tools: {} }
      }
    );
    server.setRequestHandler(import_types.ListToolsRequestSchema, async (_, extra) => {
      if (!extra.sessionId) {
        throw new import_n8n_workflow.OperationalError("Require a sessionId for the listing of tools");
      }
      return {
        tools: this.tools[extra.sessionId].map((tool) => {
          return {
            name: tool.name,
            description: tool.description,
            // Allow additional properties on tool call input
            inputSchema: (0, import_zod_to_json_schema.zodToJsonSchema)(tool.schema, { removeAdditionalStrategy: "strict" })
          };
        })
      };
    });
    server.setRequestHandler(import_types.CallToolRequestSchema, async (request, extra) => {
      if (!request.params?.name || !request.params?.arguments) {
        throw new import_n8n_workflow.OperationalError("Require a name and arguments for the tool call");
      }
      if (!extra.sessionId) {
        throw new import_n8n_workflow.OperationalError("Require a sessionId for the tool call");
      }
      const requestedTool = this.tools[extra.sessionId].find(
        (tool) => tool.name === request.params.name
      );
      if (!requestedTool) {
        throw new import_n8n_workflow.OperationalError("Tool not found");
      }
      try {
        const result = await requestedTool.invoke(request.params.arguments);
        this.resolveFunctions[extra.sessionId]();
        this.logger.debug(`Got request for ${requestedTool.name}, and executed it.`);
        if (typeof result === "object") {
          return { content: [{ type: "text", text: JSON.stringify(result) }] };
        }
        if (typeof result === "string") {
          return { content: [{ type: "text", text: result }] };
        }
        return { content: [{ type: "text", text: String(result) }] };
      } catch (error) {
        this.logger.error(`Error while executing Tool ${requestedTool.name}: ${error}`);
        return { isError: true, content: [{ type: "text", text: `Error: ${error.message}` }] };
      }
    });
    server.onclose = () => {
      this.logger.debug("Closing MCP Server");
    };
    server.onerror = (error) => {
      this.logger.error(`MCP Error: ${error}`);
    };
    return server;
  }
}
const _McpServerSingleton = class _McpServerSingleton {
  constructor(logger) {
    this._serverData = new McpServer(logger);
  }
  static instance(logger) {
    if (!__privateGet(_McpServerSingleton, _instance)) {
      __privateSet(_McpServerSingleton, _instance, new _McpServerSingleton(logger));
      logger.debug("Created singleton for MCP Servers");
    }
    return __privateGet(_McpServerSingleton, _instance).serverData;
  }
  get serverData() {
    return this._serverData;
  }
};
_instance = new WeakMap();
__privateAdd(_McpServerSingleton, _instance);
let McpServerSingleton = _McpServerSingleton;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  McpServer,
  McpServerSingleton
});
//# sourceMappingURL=McpServer.js.map